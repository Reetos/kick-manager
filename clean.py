# -*- coding: utf-8 -*-
"""clean.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pPAoEhLwl0T-VFCHGXi48enSe_JLNS73
"""
import os
os.environ["TF_ENABLE_ONEDNN_OPTS"] = "1"
os.environ['TF_ENABLE_ONEDNN_OPTS']='0'
import matplotlib.pyplot as plt
from scipy.io import wavfile
import argparse
from glob import glob
import numpy as np
import pandas as pd
from librosa.core import resample, to_mono
import librosa
from tqdm import tqdm

import os.path
from os import path

from tkinter import filedialog

from subprocess import call


def envelope(y, rate, threshold):
    mask = []
    y = pd.Series(y).apply(np.abs)
    y_mean = y.rolling(window=int(rate/40),
                       min_periods=1,
                       center=True).max()
    for mean in y_mean:
        if mean > threshold:
            mask.append(True)
        else:
            mask.append(False)
    return mask, y_mean

def downsample_mono(path, sr):
    wav, rate = librosa.load(path)
    try:
        channel = wav.shape[1]
        if channel == 2:
            wav = to_mono(wav.T)
        elif channel == 1:
            wav = to_mono(wav.reshape(-1))
            
    except IndexError:
        wav = to_mono(wav.reshape(-1))
        pass
    except Exception as exc:
        raise exc
    wav = resample(wav, orig_sr=rate, target_sr=sr)
    wav = soundDataToInt(wav)
    return sr, wav

def soundDataToInt(data_float):
  return np.array([ int(s*32768) for s in data_float]).astype(np.int16)

'''def save_sample(sample, rate, dst_root, fn, ix):
    fn = fn.split('.wav')[0]
    dst_path = os.path.join(dst_root.split('.')[0], fn+'_{}.wav'.format(str(ix)))
    print(f'dst_path: {dst_path}')
    if os.path.exists(dst_path):
        return
    wavfile.write(dst_path, rate, sample)'''


'''def split_wavs():
    src_root = my_dir
    dst_root = 'app/clean'
    dt = 1.0
    threshold = 20
    sr = 16000
    wav_paths = glob('{}/**'.format(src_root), recursive=True)
    wav_paths = sorted([x.replace(os.sep, '/') for x in wav_paths if '.wav' in x])
    for path in tqdm(wav_paths):
        rate, wav = downsample_mono(path, sr)
        mask, y_mean = envelope(wav, rate, threshold=threshold)
        wav = wav[mask]
        delta_sample = int(dt*rate)
        fn = os.path.split(path)[-1]

        if wav.shape[0] < delta_sample:
            sample = np.zeros(shape=(delta_sample,), dtype=np.int16)
            sample[:wav.shape[0]] = wav
            save_sample(sample, rate, dst_root, fn, 0)
        else:
            trunc = wav.shape[0] % delta_sample
            for cnt, i in enumerate(np.arange(0, wav.shape[0]-trunc, delta_sample)):
                start = int(i)
                stop = int(i + delta_sample)
                sample = wav[start:stop]
                save_sample(sample, rate, dst_root, fn, cnt)
    return src_root'''

'''def test_threshold(args):
    src_root = args.src_root
    wav_paths = glob('{}/**'.format(src_root), recursive=True)
    wav_path = [x for x in wav_paths if args.fn in x]
    if len(wav_path) != 1:
        print('audio file not found for sub-string: {}'.format(args.fn))
        return
    rate, wav = downsample_mono(wav_path[0], args.sr)
    mask, env = envelope(wav, rate, threshold=args.threshold)
    plt.style.use('ggplot')
    plt.title('Signal Envelope, Threshold = {}'.format(str(args.threshold)))
    plt.plot(wav[np.logical_not(mask)], color='r', label='remove')
    plt.plot(wav[mask], color='c', label='keep')
    plt.plot(env, color='m', label='envelope')
    plt.grid(False)
    plt.legend(loc='best')
    plt.show()'''

'''if __name__ == '__main__':

    parser = argparse.ArgumentParser(description='Cleaning audio data')
    parser.add_argument('--src_root', type=str, default='', #my_dir?
                        help='directory of audio files in total duration')
    parser.add_argument('--dst_root', type=str, default='app/clean',
                        help='directory to put audio files split by delta_time')
    parser.add_argument('--delta_time', '-dt', type=float, default=1.0,
                        help='time in seconds to sample audio')
    parser.add_argument('--sr', type=int, default=16000,
                        help='rate to downsample audio')
    parser.add_argument('--fn', type=str, default='WA Future House Kick 12.wav',
                        help='file to plot over time to check magnitude')
    parser.add_argument('--threshold', type=str, default=20,
                        help='threshold magnitude for np.int16 dtype')
    args, _ = parser.parse_known_args()

    #test_threshold(args)
    #my_dir = my_fun()
    #my_dir = '/mnt/c/Users/Yuri/Documents/My Projects/kick-selector/app/kicks_mini'
    split_wavs()'''
